use crate::prelude::*;
use crate::frontend::{ast::{Statement, Position, Module, Ident}, parser::error::ParseErrorKind};
use crate::shared::typed_ids::{BindingId, ScopeId};
use std::rc::Rc;
use std::cell::RefCell;

/// Parsed sourcecode of a single Itsy module.
#[derive(Debug)]
pub struct ParsedModule {
    pub(crate) path: String,
    pub(crate) ast: Vec<Statement>,
    pub(crate) scope_id: ScopeId,
}

impl ParsedModule {
    /// Creates a new ParsedModule from a vector of Statements.
    pub fn new<S: Into<String>>(scope_id: ScopeId, path: S, ast: Vec<Statement>) -> Self {
        Self {
            path: path.into(),
            ast,
            scope_id,
        }
    }
    /// Returns an iterator over all submodules of the module.
    pub fn modules<'a>(self: &'a Self) -> impl Iterator<Item=&Module> {
        self.ast
            .iter()
            .filter_map(|s| match s {
                Statement::Module(m) => Some(m),
                _ => None,
            })
    }
    /// Returns an iterator over all use mappings in the module.
    pub fn using<'a>(self: &'a Self) -> impl Iterator<Item=(&String, &String)> {
        self.ast
            .iter()
            .filter_map(|s| match s {
                Statement::Use(u) => Some(u.mapping.iter().map(|(k, v)| (k, &v.0))),
                _ => None,
            })
            .flatten()
    }
    /// Returns an iterator over all statements in the source.
    pub fn statements<'a>(self: &'a Self) -> impl Iterator<Item=&Statement> {
        self.ast.iter()
    }
}

/// Parsed sourcecode of an Itsy program.
pub struct ParsedProgram {
    pub(crate) modules: Vec<ParsedModule>,
    pub(crate) scope_parent_map: UnorderedMap<ScopeId, ScopeId>,
    pub(crate) binding_map: Set<BindingId>,
}

impl ParsedProgram {
    /// Returns an empty ParsedProgram instance.
    pub fn new() -> Self {
        Self { modules: Vec::new(), scope_parent_map: UnorderedMap::new(), binding_map: Set::new() }
    }
    /// Adds a module to the instance.
    pub fn add_module(self: &mut Self, module: ParsedModule) {
        self.modules.push(module);
    }
    /// Sets link-state generated by module processing.
    pub fn set_link_state(self: &mut Self, link_state: LinkState) {
        let LinkState { scope_parent_map, binding_map, .. } = link_state;
        self.scope_parent_map = scope_parent_map;
        self.binding_map = binding_map;
    }
    /// Returns an iterator over all modules in the program.
    pub fn modules(self: &Self) -> impl Iterator<Item=&ParsedModule> {
        self.modules.iter()
    }
}

/// Parse flags, used to determine if some input is currently legal.
#[derive(Clone, Copy, Debug)]
pub(super) struct ParserFlags {
    pub in_trait: bool,
    pub in_function: bool,
    pub in_loop: bool,
    pub is_dead: bool,
}

impl ParserFlags {
    fn new() -> Self {
        ParserFlags {
            in_trait: false,
            in_function: false,
            in_loop: false,
            is_dead: false,
        }
    }
}

pub(super) struct VarDecl {
    pub ident: Ident,
    pub binding_id: BindingId,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub(super) enum ScopeKind {
    /// Blocks are fully transparent to parent bindings.
    Block,
    /// Closures are transparent to parent bindings, but they will have to be
    /// converted to struct member access since that's how closures 'close over' variables.
    Closure,
    /// Functions are non-transparent. Parent scope bindings are inaccessible.
    Function,
    /// Modules
    Module,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub(super) enum ScopeBindingType {
    /// Binding originates in the current scope or is reachable through transparent scopes.
    Local(BindingId),
    /// Binding originates outside the current closure and needs to be captured.
    Parent(BindingId),
    /// Not a binding or behind a non-transparent scope.
    None,
}

impl ScopeBindingType {
    pub fn binding_id(self: &Self) -> Option<BindingId> {
        match self {
            &Self::Local(binding_id) => Some(binding_id),
            &Self::Parent(binding_id) => Some(binding_id),
            Self::None => None,
        }
    }
}

/// Parser link state required for contiguous enumeration of scope and binding ids.
#[derive(Debug)]
pub struct LinkState {
    pub(super) next_scope_id: ScopeId,
    pub(super) next_binding_id: BindingId,
    pub(super) scope_parent_map: UnorderedMap<ScopeId, ScopeId>,
    pub(super) binding_map: Set<BindingId>,
}

impl LinkState {
    pub fn new() -> Self {
        Self {
            next_scope_id: ScopeId::new(0),
            next_binding_id: BindingId::new(0),
            scope_parent_map: UnorderedMap::new(),
            binding_map: Set::new(),
        }
    }
}

/// A scope that exists temporarily during parsing.
pub(super) struct Scope {
    scope_id: ScopeId,
    parent_scope_id: ScopeId,
    kind: ScopeKind,
    pub have_bindings: Map<String, BindingId>,
    require_bindings: Set<BindingId>,
}

/// Interal parser state, tracked via RC through the Input type.
pub(super) struct ParserState { // cannot implement clone because cell requires inner to be copy to be able to be cloned
    len: usize,
    max_parsed: (Option<ParseErrorKind>, usize),
    flags: ParserFlags,
    pub scope_stack: Vec<Scope>,
    pub link_state: LinkState,
}

/// Parser input
#[derive(Clone)]
pub(super) struct Input<'a> {
    pub data: &'a str,
    pub state: Rc<RefCell<ParserState>>,
}

impl<'a> Debug for Input<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let max_parsed = self.max_parsed();
        f.debug_struct("Input")
         .field("data", &self.data)
         .field("max_parsed", &max_parsed)
         .field("flags", &self.state.borrow().flags)
         .finish()
    }
}

impl<'a> Input<'a> {
    /// Create new parser input containing referenced parser state from input string.
    pub fn new(data: &'a str, link_state: LinkState) -> Self {
        Input {
            data: data,
            state: Rc::new(RefCell::new(ParserState {
                len             : data.len(),
                max_parsed      : (None, 0),
                flags           : ParserFlags::new(),
                scope_stack     : Vec::new(),
                link_state      : link_state,
            }))
        }
    }
    /// Create parser input from existing input and an unparsed substring.
    pub fn from_str(self: &Self, data: &'a str) -> Self {
        Input {
            data    : data,
            state   : self.state.clone(),
        }
    }
    /// Returns the current 0-based parser position.
    pub fn position(self: &Self) -> Position {
        Position(self.state.borrow().len - self.data.len())
    }
    /// Calls given function with mutable max parsed position and optional error at that position.
    pub fn max_parsed_mut(self: &Self, inner: impl Fn(&mut (Option<ParseErrorKind>, usize))) {
        let mut max_parsed = self.state.borrow().max_parsed.clone();
        inner(&mut max_parsed);
        self.state.borrow_mut().max_parsed = max_parsed;
    }
    /// Returns max. parsed position and potential error encountered at that position.
    pub fn max_parsed(self: &Self) -> (Option<ParseErrorKind>, usize) {
        let max_parsed = self.state.borrow().max_parsed.clone();
        let result = max_parsed.clone();
        self.state.borrow_mut().max_parsed = max_parsed;
        result
    }
    /// Calls given function with mutable parser flags.
    pub fn flags_mut(self: &Self, inner: impl Fn(&mut ParserFlags)) {
        let mut flags = self.state.borrow().flags;
        inner(&mut flags);
        self.state.borrow_mut().flags = flags;
    }
    /// Returns current parser flags.
    pub fn flags(self: &Self) -> ParserFlags {
        self.state.borrow().flags
    }
    /// Pushes a new scope onto the scope stack.
    pub fn push_scope(self: &Self, scope_type: ScopeKind) -> (ScopeId, BindingId) {
        let mut state = self.state.borrow_mut();
        let scope_id = state.link_state.next_scope_id;
        let parent_scope_id = state.scope_stack.last().map_or(ScopeId::new(0), |s| s.scope_id);
        state.scope_stack.push(Scope { scope_id, parent_scope_id, kind: scope_type, have_bindings: Map::new(), require_bindings: Set::new() });
        state.link_state.next_scope_id = scope_id.next();
        (scope_id, state.link_state.next_binding_id)
    }
    /// Pops current scope, recording it in the parent scope map or reverting it (restore continguous scope id).
    pub fn pop_scope(self: &Self, revert: Option<(ScopeId, BindingId)>) {
        let mut state = self.state.borrow_mut();
        let mut scope = state.scope_stack.pop().unwrap();
        if let Some((revert_scope_id, revert_binding_id)) = revert {
            state.link_state.next_scope_id = revert_scope_id;
            state.link_state.next_binding_id = revert_binding_id;
            state.link_state.binding_map.retain(|&binding_id| binding_id < revert_binding_id);
        } else {
            state.link_state.scope_parent_map.insert(scope.scope_id, scope.parent_scope_id);
            let scope_bindings = replace(&mut scope.have_bindings, Map::new());
            for (name, binding_id) in scope_bindings.into_iter() {
                state.link_state.binding_map.insert(binding_id);
            }
        }
    }
    /// Returns the current scope id.
    pub fn scope_id(self: &Self) -> ScopeId {
        self.state.borrow().scope_stack.last().unwrap().scope_id
    }
    /// Registers a binding with the current scope.
    pub fn add_binding(self: &Self, name: &str) -> BindingId {
        let mut state = self.state.borrow_mut();
        let binding_id = state.link_state.next_binding_id;
        state.scope_stack.last_mut().unwrap().have_bindings.insert(name.to_string(), binding_id);
        state.link_state.next_binding_id = binding_id.next();
        binding_id
    }
    /// Whether a scope or its parents have a binding.
    pub fn has_binding(self: &Self, name: &str) -> ScopeBindingType {
        let state = self.state.borrow();
        // initially assume binding is local
        let mut is_local = true;
        for scope in state.scope_stack.iter().rev() {
            if let Some(&binding_id) = scope.have_bindings.get(name) {
                // binding found, return type
                return if is_local { ScopeBindingType::Local(binding_id) } else { ScopeBindingType::Parent(binding_id) };
            } else if scope.kind == ScopeKind::Closure {
                // binding not found and scope is a closure, downgrade protential binding type (if found) to Parent
                is_local = false;
            } else if scope.kind == ScopeKind::Function {
                // function scope encountered, binding not found, fall through to exit
                break;
            }
        }
        return ScopeBindingType::None;
    }
    /// Adds a required binding to a closure scope (and potentially its parent closure, if any)
    pub fn require_binding(self: &Self, binding_id: BindingId) {
        let mut state = self.state.borrow_mut();
        for scope in state.scope_stack.iter_mut().rev() {
            if scope.have_bindings.values().find(|&&b| b == binding_id).is_some() {
                // binding already exists
                panic!("Binding to be required already exists in scope");
            } else if scope.kind == ScopeKind::Closure {
                // have found the nearest closure scope, add required binding
                scope.require_bindings.insert(binding_id);
                return;
            } else if scope.kind == ScopeKind::Function {
                // function scope encountered, apparently a binding was required on a non-closure, fall through to panic
                break;
            }
        }
        panic!("Could not find a closure for the binding to be required by");
    }
    /// Takes (removes) the required bindings from this closure scope, also propagates any requirements to parent closures.
    pub fn take_required_bindings(self: &Self) -> Vec<BindingId> {
        let mut state = self.state.borrow_mut();
        let scope = state.scope_stack.last_mut().unwrap();
        let bindings: Vec<_> = replace(&mut scope.require_bindings, Set::new()).into_iter().collect();
        for scope in state.scope_stack.iter_mut().rev().skip(1) {
            if scope.kind == ScopeKind::Closure {
                // propagate required bindings to parent closure
                for binding in &bindings {
                    scope.require_bindings.insert(binding.clone());
                }
                break;
            } else if scope.kind == ScopeKind::Function {
                // function scope encountered, no need to look any further for closures
                break;
            }
        }
        bindings
    }
    /// Consumes this parser state into a link state.
    pub fn take_linkstate(self: &Self) -> LinkState {
        let mut state = self.state.borrow_mut();
        replace(&mut state.link_state, LinkState::new())
    }
}

impl<'a> Deref for Input<'a> {
    type Target = &'a str;
    fn deref(self: &Self) -> &Self::Target {
        &self.data
    }
}

impl<'a> PartialEq for Input<'a> {
    fn eq(self: &Self, other: &Self) -> bool {
        self.data == other.data
    }
}

/// Parser output
pub(super) type Output<'a, O> = nom::IResult<Input<'a>, O, Failure<'a>>;

/// Parser failure. Converted to ParseError on return of the parse() function to remove the lifetime bound.
#[derive(Debug)]
pub(super) struct Failure<'a> {
    pub input: Input<'a>,
    pub kind: ParseErrorKind,
}