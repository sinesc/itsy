//! AST datastructures generated by the parser and processed by the resolver.

use crate::internals::resolved::{EnumVariant, ImplTrait};
use crate::prelude::*;
use crate::shared::meta::{Type, ConstantValue};
use crate::shared::{impl_as_getter, MetaContainer, {typed_ids::{BindingId, FunctionId, ScopeId, TypeId, ConstantId}, numeric::Numeric, Progress, parts_to_path}};
use crate::frontend::resolver::error::ResolveErrorKind;

/// TypeId handling for typeable AST structures.
pub(crate) trait Typeable {
    /// Returns the type_id.
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId>;
    /// Returns a mutable reference to the type_id.
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId);
}

/// Implements the Typeable trait for given structure.
macro_rules! impl_typeable {
    ($struct_name:ident) => {
        impl Typeable for $struct_name {
            fn type_id(self: &Self, _: &impl MetaContainer) -> Option<TypeId> {
                self.type_id
            }
            fn set_type_id(self: &mut Self, _bindings: &mut impl MetaContainer, type_id: TypeId) {
                self.type_id = Some(type_id);
            }
        }
    };
}

impl Typeable for TypeId {
    fn type_id(self: &Self, _: &impl MetaContainer) -> Option<TypeId> {
        Some(*self)
    }
    fn set_type_id(self: &mut Self, _bindings: &mut impl MetaContainer, _type_id: TypeId) {
        panic!("Cannot mutate TypeId through Typeable trait.")
    }
}

impl Typeable for Option<TypeId> {
    fn type_id(self: &Self, _: &impl MetaContainer) -> Option<TypeId> {
        *self
    }
    fn set_type_id(self: &mut Self, _bindings: &mut impl MetaContainer, _type_id: TypeId) {
        panic!("Cannot mutate Option<TypeId> through Typeable trait.")
    }
}

/// Implements the Display trait for given structure.
macro_rules! impl_display {
    ($struct_name:ident, $format:literal $(, $field:tt)*) => {
        impl Display for $struct_name {
            fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, $format $(, self.$field)*)
            }
        }
    };
}

pub(crate) enum Resolvables {
    TypeId(TypeId),
    BindingId(BindingId),
    ConstantId(ConstantId),
    FunctionId(FunctionId),
    Progress(Progress),
}

/// Resolvable AST structures.
pub(crate) trait Resolvable: Display {
    /// Returns list of resolvable ids.
    fn resolvables(self: &Self) -> Vec<Resolvables>;
    /// Number of resolved and total items.
    fn num_resolved(self: &Self, container: &impl MetaContainer) -> Progress {
        let resolvables = self.resolvables();
        let mut progress = Progress::zero();
        let mut seen = Set::new();
        for resolvable in resolvables {
            progress = progress + match resolvable {
                Resolvables::TypeId(type_id) => self.check_type_id(container, type_id, &mut seen),
                Resolvables::BindingId(binding_id) => {
                    let binding = container.binding_by_id(binding_id);
                    if let Some(type_id) = binding.type_id {
                        self.check_type_id(container, type_id, &mut seen)
                    } else {
                        Progress::new(0, 1)
                    }
                },
                Resolvables::ConstantId(constant_id) => self.check_constant_id(container, constant_id, &mut seen),
                Resolvables::FunctionId(function_id) => self.check_function_id(container, function_id, &mut seen),
                Resolvables::Progress(progress) => progress,
            };
        }
        progress
    }
    /// Whether the structure is fully resolved.
    fn is_resolved(self: &Self, container: &impl MetaContainer) -> bool {
        self.num_resolved(container).done()
    }
    /// Error kind incase the item could not be resolved.
    fn unresolved_error(self: &Self) -> ResolveErrorKind {
        ResolveErrorKind::CannotResolve(format!("{}", self))
    }
    /// Recursively checks how much of a type is resolved.
    fn check_type_id(self: &Self, container: &impl MetaContainer, type_id: TypeId, seen: &mut Set<TypeId>) -> Progress {
        if seen.contains(&type_id) {
            Progress::new(0, 0)
        } else {
            seen.insert(type_id);
            match container.type_by_id(type_id) {
                Type::void |
                Type::u8 | Type::u16 | Type::u32 | Type::u64 |
                Type::i8 | Type::i16 | Type::i32 | Type::i64 |
                Type::f32 | Type::f64 |
                Type::bool |
                Type::String => Progress::new(1, 1),
                Type::Array(a) => a.type_id.map_or(Progress::new(0, 1), |type_id| self.check_type_id(container, type_id, seen)),
                Type::Enum(e) => {
                    e.primitive.map_or(Progress::new(1, 1), |(type_id, _)| self.check_type_id(container, type_id, seen))
                    + e.variants.iter()
                        .map(|(_, variant)| self.check_enum_variant(container, variant, seen))
                        .fold(Progress::zero(), |acc, a| acc + a)
                    + e.impl_traits.iter()
                        .map(|(impl_type_id, impl_trait)| self.check_impl_trait(container, *impl_type_id, impl_trait, seen))
                        .fold(Progress::zero(), |acc, a| acc + a)
                },
                Type::Struct(s) => {
                    s.fields.iter()
                        .map(|(_, opt_type_id)| opt_type_id.map_or(Progress::new(0, 1), |type_id| self.check_type_id(container, type_id, seen)))
                        .fold(Progress::zero(), |acc, a| acc + a)
                    + s.impl_traits.iter()
                        .map(|(impl_type_id, impl_trait)| self.check_impl_trait(container, *impl_type_id, impl_trait, seen))
                        .fold(Progress::zero(), |acc, a| acc + a)
                },
                Type::Trait(t) => {
                    t.provided.iter()
                        .map(|(_, opt_const_id)| opt_const_id.map_or(Progress::new(0, 1), |const_id| self.check_constant_id(container, const_id, seen)))
                        .fold(Progress::zero(), |acc, a| acc + a)
                    + t.required.iter()
                        .map(|(_, opt_const_id)| opt_const_id.map_or(Progress::new(0, 1), |const_id| self.check_constant_id(container, const_id, seen)))
                        .fold(Progress::zero(), |acc, a| acc + a)
                },
                Type::Callable(c) => {
                    c.ret_type_id.map_or(Progress::new(0, 1), |type_id| self.check_type_id(container, type_id, seen))
                    + c.arg_type_ids.iter()
                        .map(|opt_type_id| opt_type_id.map_or(Progress::new(0, 1), |type_id| self.check_type_id(container, type_id, seen)))
                        .fold(Progress::zero(), |acc, a| acc + a)
                },
            }
        }
    }
    /// Recursively checks how much of an enum variant is resolved.
    fn check_enum_variant(self: &Self, container: &impl MetaContainer, variant: &EnumVariant, seen: &mut Set<TypeId>) -> Progress {
        match variant {
            EnumVariant::Simple(_) => Progress::new(1, 1),
            EnumVariant::Data(opt_type_ids) => {
                opt_type_ids.iter()
                    .map(|opt_type_id| opt_type_id.map_or(Progress::new(0, 1), |type_id| self.check_type_id(container, type_id, seen)))
                    .fold(Progress::zero(), |acc, a| acc + a)
            }
        }
    }
    /// Recursively checks how much of a trait implementation is resolved.
    fn check_impl_trait(self: &Self, container: &impl MetaContainer, impl_type_id: TypeId, impl_trait: &ImplTrait, seen: &mut Set<TypeId>) -> Progress {
        self.check_type_id(container, impl_type_id, seen)
        + impl_trait.functions.iter().map(|(_, opt_const_id)| opt_const_id.map_or(Progress::new(0, 1), |const_id| self.check_constant_id(container, const_id, seen)))
            .fold(Progress::zero(), |acc, a| acc + a)
    }
    /// Recursively checks how much of a constant is resolved.
    fn check_constant_id(self: &Self, container: &impl MetaContainer, constant_id: ConstantId, seen: &mut Set<TypeId>) -> Progress {
        let constant = container.constant_by_id(constant_id);
        if let Some(type_id) = constant.type_id {
            let mut progress = self.check_type_id(container, type_id, seen);
            progress = progress + match constant.value {
                ConstantValue::Function(function_id) => {
                    self.check_function_id(container, function_id, seen)
                }
                ConstantValue::Discriminant(_) => {
                    Progress::zero()
                }
            };
            progress
        } else {
            Progress::new(0, 1)
        }
    }
    /// Recursively checks how much of a function signature is resolved.
    fn check_function_id(self: &Self, _container: &impl MetaContainer, _function_id: FunctionId, _seen: &mut Set<TypeId>) -> Progress {
        Progress::new(1, 1) // FIXME, need to add function lookup to one of the containers
    }
}

/// Implements the Resolvable trait for given structure.
/// Accepted syntax:
///     impl_resolvable!(enum Statement|Expression|...)
///     impl_resolvable!(always MyStruct)
///     impl_resolvable!(MyStruct { field: Item|OptionalItem|TypeId... })
macro_rules! impl_resolvable {
    (@append $field:expr, Item) => {
        $field.resolvables()
    };
    (@append $field:expr, OptionalItem) => { // These are items that are not required, e.g. the InlineType in LetBindings is optional here: let x: u8 = 1u8;
        $field.as_ref().map_or(Vec::new(), |expr| expr.resolvables())
    };
    (@append $field:expr, ItemList) => {
        $field.iter().fold(Vec::new(), |mut acc, item| { acc.append(&mut item.resolvables()); acc })
    };
    (@append $field:expr, ItemList1) => {
        $field.iter().fold(Vec::new(), |mut acc, item| { acc.append(&mut item.1.resolvables()); acc })
    };
    (@append $field:expr, ItemMap) => {
        $field.iter().map(|(_k, v)| v).fold(Vec::new(), |mut acc, item| { acc.append(&mut item.resolvables()); acc })
    };
    (@append $field:expr, TypeId) => { // TypeIds are wrapped in Option but they are not 'optional', they must be resolved eventually. So not naming this OptionalItem.
        if let Some(type_id) = $field {
            vec![ Resolvables::TypeId(type_id) ]
        } else {
            vec![ Resolvables::Progress(Progress::new(0, 1)) ]
        }
    };
    (@append $field:expr, ConstantId) => {
        if let Some(constant_id) = $field {
            vec![ Resolvables::ConstantId(constant_id) ]
        } else {
            vec![ Resolvables::Progress(Progress::new(0, 1)) ]
        }
    };
    (@append $field:expr, FunctionId) => {
        if let Some(function_id) = $field {
            vec![ Resolvables::FunctionId(function_id) ]
        } else {
            vec![ Resolvables::Progress(Progress::new(0, 1)) ]
        }
    };
    (@append $field:expr, BindingId) => {
        vec![ Resolvables::BindingId($field) ]
    };
    (@append $field:expr, BindingList) => {
        $field.iter().fold(Vec::new(), |mut acc, item| { acc.push(Resolvables::BindingId(*item)); acc })
    };
    (@append $field:expr, $unsupported:ident) => {
        compile_error!(stringify!(Unsupported impl_resolvable type $unsupported))
    };
    // impl_resolvable!(enum Statement|Expression|...)
    (enum $enum_type:ident ) => {
        impl Resolvable for $enum_type {
            fn resolvables(self: &Self) -> Vec<Resolvables> {
                impl_matchall!(self, $enum_type, item, { item.resolvables() })
            }
        }
    };
    // impl_resolvable!(always MyAST)
    (always $ty:ident ) => {
        impl Resolvable for $ty {
            fn resolvables(self: &Self) -> Vec<Resolvables> {
                vec![ Resolvables::Progress(Progress::new(1, 1)) ]
            }
        }
    };
    // impl_resolvable!(MyStruct { field: Item|OptionalItem|TypeId... })
    ($struct_name:ident { $( $field_name:ident : $field_ty:ident ),+ $( , )? } ) => {
        impl Resolvable for $struct_name {
            fn resolvables(self: &Self) -> Vec<Resolvables> {
                let mut result = Vec::new();
                $(
                    result.append(&mut impl_resolvable!(@append self.$field_name, $field_ty));
                )+
                return result;
            }
        }
    };
}

/// A position in the source code.
#[derive(Copy, Clone)]
pub struct Position(pub(crate) usize);

impl Position {
    /// Create a new position.
    pub fn new(offset: usize) -> Self {
        Self(offset)
    }
    /// Compute 1-based line/column number in string.
    pub fn loc(self: &Self, input: &str) -> (u32, u32) {
        let mut parsed = &input[0..self.0];
        let mut line = 1;
        while { // can't use let parsed.lines() here as a line-break at the end is ignored
            let mut break_char = '\0';
            if let Some(nl) = parsed.find(|c| if c == '\n' || c == '\r' { break_char = c; true } else { false }) {
                parsed = &parsed[nl+1..];
                if break_char == '\r' && parsed.starts_with('\n') { // skip \n after \r on windows
                    parsed = &parsed[1..];
                }
                line += 1;
                true
            } else {
                false
            }
        } {}
        (line, parsed.len() as u32 + 1)
    }
}

impl_display!(Position, "{}", 0);

impl Debug for Position {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Position({})", self.0)
    }
}

/// Source code position handling for AST structures associated with a position.
pub(crate) trait Positioned {
    /// Returns the structure's position.
    fn position(self: &Self) -> Position;
}

/// Implements the Position trait for given structure.
macro_rules! impl_positioned {
    ($struct_name:ident) => {
        impl Positioned for $struct_name {
            fn position(self: &Self) -> Position {
                self.position
            }
        }
    };
}

/// Implements a match block with cases for all variants of Expression or Statement
macro_rules! impl_matchall {
    (@match $self:ident, $enum_name:ident, $val_name:ident, $code:tt, [ $( $pattern:pat => $default:tt )? ] $(, $variant_name:ident)+) => {
        match $self {
            $(
                $enum_name::$variant_name($val_name) => $code,
            )+
            $( $pattern => $default )?
        }
    };
    ($self:ident, Expression, $val_name:ident, $code:tt) => {
        impl_matchall!(@match $self, Expression, $val_name, $code, [ ], Literal, Constant, Variable, Assignment, BinaryOp, UnaryOp, Block, IfBlock, MatchBlock, Closure, AnonymousFunction)
    };
    ($self:ident, Statement, $val_name:ident, $code:tt) => {
        impl_matchall!(@match $self, Statement, $val_name, $code, [ ], LetBinding, Function, StructDef, ImplBlock, TraitDef, ForLoop, WhileLoop, IfBlock, Block, Return, Break, Continue, Expression, Module, UseDecl, EnumDef)
    };
    ($self:ident, BinaryOperand, $val_name:ident, $code:tt) => {
        impl_matchall!(@match $self, BinaryOperand, $val_name, $code, [ ], Expression, ArgumentList, Member, TypeName)
    };
    ($self:ident, InlineType, $val_name:ident, $code:tt) => {
        impl_matchall!(@match $self, InlineType, $val_name, $code, [ ], TypeName, ArrayDef, CallableDef)
    };
    ($self:ident, $unsupported:ident, $val_name:ident, $code:tt) => {
        compile_error!(stringify!(Unsupported impl_matchall type $unsupported))
    };
}

#[derive(Copy, Clone, Debug, PartialEq)]
pub enum ControlFlowType {
    Break,
    Return,
    Continue,
}

/// Provides information whether this AST structure causes an unconditional control flow interruptions, e.g. return from function, break from loop.
pub(crate) trait ControlFlow {
    fn control_flow(self: &Self) -> Option<ControlFlowType> {
        self.identify_control_flow(false)
    }
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType>;
}

/// Visibility of types and functions.
#[derive(Debug, PartialEq)]
pub enum Visibility {
    Private,
    Public,
}


/// An identifier for an item, e.g. `item`.
#[derive(Debug, Clone)]
pub struct Ident {
    pub position: Position,
    pub name: String,
}

impl_positioned!(Ident);
impl_display!(Ident, "{}", name);

impl Ident {
    pub fn to_string(self: &Self) -> String {
        self.name.clone()
    }
}

impl AsRef<str> for Ident {
    fn as_ref(&self) -> &str {
        &self.name
    }
}


/// A path to an item, e.g. `path::to::item`.
#[derive(Debug)]
pub struct Path {
    pub position: Position,
    pub segments: Vec<Ident>,
}

impl_positioned!(Path);

impl Path {
    /// Removes and returns the last path element.
    pub fn pop(self: &mut Self) -> Ident {
        self.segments.pop().unwrap()
    }
    /// Inserts a new path element at the beginning of the path.
    pub fn unshift(self: &mut Self, other: Ident) {
        let old = replace(&mut self.segments, Vec::new());
        self.segments.push(other);
        self.segments.extend(old.into_iter());
    }
    /// Converts path to string, optionally skipping elements from start (negative skip) or end (positive) of path.
    pub fn to_string(self: &Self, skip: isize) -> String {
        if skip < 0 {
            parts_to_path(&self.segments[0..(self.segments.len() as isize + skip) as usize])
        } else if skip > 0 {
            parts_to_path(&self.segments[skip as usize..])
        } else {
            parts_to_path(&self.segments)
        }
    }
}

impl Display for Path {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", parts_to_path(&self.segments))
    }
}


/// An itsy statement.
pub enum Statement {
    LetBinding(LetBinding),
    Function(Function),
    StructDef(StructDef),
    ImplBlock(ImplBlock),
    TraitDef(TraitDef),
    ForLoop(ForLoop),
    WhileLoop(WhileLoop),
    IfBlock(IfBlock),
    Block(Block),
    Return(Return),
    Break(Break),
    Continue(Continue),
    Expression(Expression),
    Module(ModuleDecl),
    UseDecl(UseDecl),
    EnumDef(EnumDef),
}

impl_resolvable!(enum Statement);

impl Statement {
    /// Returns whether the statement could also be an expression. Notably, an expression could not be since Statement::Expression is ; terminated
    pub fn is_expression(self: &Self) -> bool {
        match self {
            Statement::IfBlock(if_block) => if_block.if_block.result.is_some(),
            Statement::Block(block) => block.result.is_some(),
            _ => false,
        }
    }
    /// Converts the statement into an expression or return None
    pub fn into_expression(self: Self) -> Option<Expression> {
        match self {
            Statement::IfBlock(if_block)        => Some(Expression::IfBlock(Box::new(if_block))),
            Statement::Block(block)             => Some(Expression::Block(Box::new(block))),
            Statement::Expression(expression)   => Some(expression),
            Statement::Return(ret)              => Some(ret.expr),
            _                                   => None,
        }
    }
}

impl ControlFlow for Statement {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        match self {
            Statement::Return(_)    => Some(ControlFlowType::Return),
            Statement::IfBlock(v)   => v.identify_control_flow(scan_blocks),
            Statement::Block(v)     => v.identify_control_flow(scan_blocks),
            Statement::ForLoop(v)     => v.identify_control_flow(scan_blocks),
            Statement::WhileLoop(v)     => v.identify_control_flow(scan_blocks),
            Statement::Expression(v)=> v.identify_control_flow(scan_blocks),
            _                       => None,
        }
    }
}

impl Positioned for Statement {
    fn position(self: &Self) -> Position {
        impl_matchall!(self, Statement, item, { item.position() })
    }
}

impl Display for Statement {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        impl_matchall!(self, Statement, item, { write!(f, "{}", item) })
    }
}

impl Debug for Statement {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        impl_matchall!(self, Statement, item, { write!(f, "{:#?}", item) })
    }
}


/// A module declaration, e.g. `mod mymodule;`.
#[derive(Debug)]
pub struct ModuleDecl {
    pub position    : Position,
    pub ident       : Ident,
}

impl_positioned!(ModuleDecl);
impl_resolvable!(always ModuleDecl);
impl_display!(ModuleDecl, "mod {}", ident);

impl ModuleDecl {
    /// Returns the module name as a string
    pub fn name(self: &Self) -> &str {
        &self.ident.name
    }
}

/// A use declaration, e.g. `use frontend::{ast::Use, parser::{parse, parse_module}};`.
#[derive(Debug)]
pub struct UseDecl {
    pub position    : Position,
    pub mapping     : UnorderedMap<String, (String, bool)>,
}

impl_positioned!(UseDecl);
impl_display!(UseDecl, "{:?}", mapping); // TODO: formatting

impl Resolvable for UseDecl {
    fn resolvables(self: &Self) -> Vec<Resolvables> {
        vec!(Resolvables::Progress(Progress::new(self.mapping.iter().map(|(_, (_, r))| *r as usize).sum(), self.mapping.len())))
    }
}


/// A let binding, e.g. `let a = 1;`.
#[derive(Debug)]
pub struct LetBinding {
    pub position    : Position,
    pub ident       : Ident,
    pub mutable     : bool,
    pub expr        : Option<Expression>,
    pub ty          : Option<InlineType>,
    pub binding_id  : BindingId,
}

impl_positioned!(LetBinding);
impl_resolvable!(LetBinding {
    expr: OptionalItem,
    ty: OptionalItem,
    binding_id: BindingId
});

impl Display for LetBinding {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(e) = &self.expr { write!(f, "let {} = {}", self.ident, e) } else { write!(f, "let {}", self.ident) }
    }
}

impl Typeable for LetBinding {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        bindings.binding_by_id(self.binding_id).type_id
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        bindings.binding_by_id_mut(self.binding_id).type_id = Some(type_id);
    }
}


#[derive(Debug)]
pub struct FunctionShared {
    pub position: Position,
    pub sig     : Signature,
    pub block   : Option<Block>,
    pub scope_id: ScopeId,
}

impl_display!(FunctionShared, "{} {{ ... }}", sig);
impl_resolvable!(FunctionShared {
    sig: Item,
    block: OptionalItem,
});


/// A closure, e.g. `|a: u8, b: String| -> u16 { ... }`.
#[derive(Debug)]
pub struct Closure {
    pub shared              : FunctionShared,
    pub struct_type_id      : Option<TypeId>,
    pub type_id             : Option<TypeId>,
    pub function_id         : Option<FunctionId>,
    pub required_bindings   : Vec<BindingId>,
}

impl_typeable!(Closure);
impl_resolvable!(Closure {
    shared: Item,
    struct_type_id: TypeId,
    type_id: TypeId,
    function_id: FunctionId,
    required_bindings: BindingList,
});

impl Positioned for Closure {
    fn position(self: &Self) -> Position {
        self.shared.position
    }
}

impl Display for Closure {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "|...|{:?}", self.shared.block) // todo: not super helpful
    }
}


/// A function definition, e.g. `fn myfunc(a: u8, b: String) -> u16 { ... }`.
#[derive(Debug)]
pub struct Function {
    pub shared      : FunctionShared,
    pub constant_id : Option<ConstantId>,
}

impl_resolvable!(Function {
    shared: Item,
    constant_id: ConstantId,
});

impl Positioned for Function {
    fn position(self: &Self) -> Position {
        self.shared.position
    }
}

impl Display for Function {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.shared.sig.ident.name)
    }
}

impl Typeable for Function {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        match self.constant_id {
            Some(constant_id) => bindings.constant_by_id(constant_id).type_id,
            None => None,
        }
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        match self.constant_id {
            Some(constant_id) => bindings.constant_by_id_mut(constant_id).type_id = Some(type_id),
            None => { /* not resolved to constant yet */ },
        }
    }
}


/// The type signature of an anonymous function/closure.
#[derive(Debug)]
pub struct CallableDef {
    pub position: Position,
    pub args    : Vec<InlineType>,
    pub ret     : Option<InlineType>,
    pub type_id : Option<TypeId>,
}

impl_positioned!(CallableDef);
impl_typeable!(CallableDef);
impl_resolvable!(CallableDef {
    args: ItemList,
    ret: OptionalItem,
    type_id: TypeId,
});

impl Display for CallableDef {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let args = self.args.iter().map(|b| format!("{}", b)).collect::<Vec<String>>().join(", ");
        match &self.ret {
            Some(ret) => write!(f, "fn({}) -> {}", args, ret),
            None => write!(f, "fn({})", args),
        }
    }
}

/// The signatures of a function or closure.
#[derive(Debug)]
pub struct Signature {
    pub ident   : Ident,
    pub args    : Vec<LetBinding>, // TODO: should be params
    pub ret     : Option<InlineType>,
    pub vis     : Visibility,
}

impl_resolvable!(Signature {
    args: ItemList,
    ret: OptionalItem,
});

impl Signature {
    // FIXME use impl_resolved2 macro inner cases here
    pub(crate) fn ret_resolved(self: &Self, bindings: &impl MetaContainer) -> bool {
        self.ret.as_ref().map_or(true, |ret| ret.type_id(bindings).is_some())
    }
    pub(crate) fn ret_type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        self.ret.as_ref().map_or(Some(TypeId::VOID), |ret| ret.type_id(bindings))
    }
    pub(crate) fn args_resolved(self: &Self, bindings: &impl MetaContainer) -> bool {
        self.args.iter().all(|arg| arg.ty.as_ref().map_or(false, |type_name| type_name.type_id(bindings).is_some()))
    }
    pub(crate) fn arg_type_ids(self: &Self, bindings: &impl MetaContainer) -> Vec<Option<TypeId>> {
        self.args.iter().map(|arg| arg.ty.as_ref().map_or(None, |type_name| type_name.type_id(bindings))).collect()
    }
}

impl Display for Signature {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} {{ {} }}", self.ident, self.args.iter().map(|b| format!("{}", b)).collect::<Vec<String>>().join(", "))
    }
}

impl Positioned for Signature {
    fn position(self: &Self) -> Position {
        self.ident.position
    }
}


/// A type name (a type-id attached to a Path).
#[derive(Debug)]
pub struct TypeName {
    pub path    : Path,
    pub type_id : Option<TypeId>,
}

impl_typeable!(TypeName);
impl_display!(TypeName, "{:?}", path);
impl_resolvable!(TypeName {
    type_id: TypeId,
});

impl TypeName {
    /// Returns a type with the given name and an unresolved type-id.
    pub fn from_path(path: Path) -> Self {
        TypeName {
            path    : path,
            type_id : None,
        }
    }
    pub fn from_str(name: &str, position: Position) -> Self {
        TypeName {
            path    : Path { segments: vec! [ Ident { position: position, name: name.to_string() } ], position: position },
            type_id : None,
        }
    }
}

impl Positioned for TypeName {
    fn position(self: &Self) -> Position {
        self.path.position
    }
}

/// An inlineable type (e.g. `MyStruct` or `[ MyInt; 16 ]`).
#[derive(Debug)]
pub enum InlineType {
    TypeName(TypeName),
    ArrayDef(Box<ArrayDef>),
    CallableDef(Box<CallableDef>),
}

impl_resolvable!(enum InlineType);

impl Display for InlineType {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::TypeName(type_name) => write!(f, "{}", type_name),
            Self::ArrayDef(array_def) => write!(f, "{}", array_def),
            Self::CallableDef(callable_def) => write!(f, "{}", callable_def),
        }
    }
}

impl Typeable for InlineType {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        match &self {
            InlineType::ArrayDef(array_def) => array_def.type_id(bindings),
            InlineType::TypeName(type_name) => type_name.type_id(bindings),
            InlineType::CallableDef(callable_def) => callable_def.type_id(bindings),
        }
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        match self {
            InlineType::ArrayDef(array_def) => array_def.set_type_id(bindings, type_id),
            InlineType::TypeName(type_name) => type_name.set_type_id(bindings, type_id),
            InlineType::CallableDef(callable_def) => callable_def.set_type_id(bindings, type_id),
        }
    }
}


/// An array definition, e.g. `[ MyInt ]`.
#[derive(Debug)]
pub struct ArrayDef {
    pub position    : Position,
    pub element_type: InlineType,
    pub type_id     : Option<TypeId>,
}

impl_positioned!(ArrayDef);
impl_typeable!(ArrayDef);
impl_display!(ArrayDef, "[ {} ]", element_type);
impl_resolvable!(ArrayDef {
    element_type: Item,
    type_id: TypeId,
});


/// The kind of a variant, either `Simple` (without associated data) or `Data`.
#[derive(Debug)]
pub enum VariantKind {
    Simple(Option<ConstantId>, Option<Literal>),
    Data(Option<ConstantId>, Vec<InlineType>),
}

impl Resolvable for VariantKind {
    fn resolvables(self: &Self) -> Vec<Resolvables> {
        match self {
            VariantKind::Data(constant_id, fields) => {
                let mut result = Vec::new();
                result.append(&mut impl_resolvable!(@append *constant_id, ConstantId));
                result.append(&mut impl_resolvable!(@append fields, ItemList));
                return result;
            },
            VariantKind::Simple(constant_id, literal) => {
                let mut result = Vec::new();
                result.append(&mut impl_resolvable!(@append *constant_id, ConstantId));
                result.append(&mut impl_resolvable!(@append literal, OptionalItem));
                return result;
            },
        }
    }
}

impl Display for VariantKind {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Simple(_, opt_lit) => if let Some(l) = opt_lit { write!(f, "{}", l) } else { write!(f, "") },
            Self::Data(_, inlines) => write!(f, "{}", inlines.iter().map(|i| format!("{}", i)).collect::<Vec<String>>().join(", ")),
        }
    }
}


/// An enum variant definition, e.g. `MyVariant(u16, f32)` or `MySimpleVariant`.
#[derive(Debug)]
pub struct VariantDef {
    pub position    : Position,
    pub ident       : Ident,
    pub kind        : VariantKind,
}

impl_display!(VariantDef, "{}{}", ident, kind);
impl_positioned!(VariantDef);
impl_resolvable!(VariantDef {
    kind: Item,
});


/// An enum definition, e.g. `enum MyEnum { A, B(u32) }`.
#[derive(Debug)]
pub struct EnumDef {
    pub position: Position,
    pub ident   : Ident,
    pub variants: Vec<VariantDef>,
    pub scope_id: ScopeId,
    pub type_id : Option<TypeId>,
    pub vis     : Visibility,
}

impl_positioned!(EnumDef);
impl_typeable!(EnumDef);
impl_display!(EnumDef, "enum {} {{ ... }}", ident);
impl_resolvable!(EnumDef {
    variants: ItemList,
    type_id: TypeId,
});

impl EnumDef {
    pub fn is_primitive(self: &Self) -> bool {
        self.variants.iter().all(|variant| match variant.kind { VariantKind::Simple(_, _) => true, _ => false })
    }
}

/// A struct definition, e.g. `struct MyStruct { a: u8, b: String }`.
#[derive(Debug)]
pub struct StructDef {
    pub position: Position,
    pub ident   : Ident,
    pub fields  : Vec<(String, InlineType)>,
    pub type_id : Option<TypeId>,
    pub vis     : Visibility,
}

impl_positioned!(StructDef);
impl_typeable!(StructDef);
impl_resolvable!(StructDef {
    fields: ItemList1,
    type_id: TypeId,
});

impl Display for StructDef {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} {{ {} }}", self.ident, self.fields.iter().map(|(n, _)| format!("{}", n)).collect::<Vec<String>>().join(", "))
    }
}


/// An `impl` block for a struct, e.g. `impl MyStruct { fn new() { ... } -> Self }`.
#[derive(Debug)]
pub struct ImplBlock {
    pub position    : Position,
    pub functions   : Vec<Function>,
    pub scope_id    : ScopeId,
    pub ty          : InlineType,
    pub trt         : Option<TypeName>,
}

impl_positioned!(ImplBlock);
impl_resolvable!(ImplBlock {
    functions: ItemList,
    ty: Item,
    trt: OptionalItem,
});

impl Display for ImplBlock {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.trt {
            Some(trt) => write!(f, "impl {} for {} {{ ... }}", trt, &self.ty),
            None => write!(f, "impl {} {{ ... }}", &self.ty),
        }
    }
}

/// A `trait` definition, e.g. `trait Demoable { fn needthis(); fn gotthis() { ... } }`.
#[derive(Debug)]
pub struct TraitDef {
    pub position    : Position,
    pub functions   : Vec<Function>,
    pub scope_id    : ScopeId,
    pub ident       : Ident,
    pub type_id     : Option<TypeId>,
    pub vis         : Visibility,
}

impl_positioned!(TraitDef);
impl_display!(TraitDef, "trait {} {{ ... }}", ident);
impl_typeable!(TraitDef);
impl_resolvable!(TraitDef {
    functions: ItemList,
    type_id: TypeId,
});


/// A for-in loop, e.g. `for i in 0..10 { ... }`.
#[derive(Debug)]
pub struct ForLoop {
    pub position: Position,
    pub iter    : LetBinding,
    pub expr    : Expression,
    pub block   : Block,
    pub scope_id: ScopeId,
}

impl_positioned!(ForLoop);
impl_display!(ForLoop, "for {} in {} {{ ... }}", iter, expr);
impl_resolvable!(ForLoop {
    iter: Item,
    expr: Item,
    block: Item,
});

impl ControlFlow for ForLoop {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        // don't propagate break/continue control flow changes to parent blocks
        match self.expr.identify_control_flow(scan_blocks) {
            Some(ControlFlowType::Break) | Some(ControlFlowType::Continue) => None,
            control_flow_type @ _ => control_flow_type,
        }
    }
}


/// A while loop, e.g. `while a < 10 { a += 1; }`.
#[derive(Debug)]
pub struct WhileLoop {
    pub position: Position,
    pub expr    : Expression,
    pub block   : Block,
    pub scope_id: ScopeId,
}

impl_positioned!(WhileLoop);
impl_display!(WhileLoop, "while {} {{ ... }}", expr);
impl_resolvable!(WhileLoop {
    expr: Item,
    block: Item,
});

impl ControlFlow for WhileLoop {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        // don't propagate break/continue control flow changes to parent blocks
        match self.expr.identify_control_flow(scan_blocks) {
            Some(ControlFlowType::Break) | Some(ControlFlowType::Continue) => None,
            control_flow_type @ _ => control_flow_type,
        }
    }
}


/// A return statement, e.g. `return false;`.
#[derive(Debug)]
pub struct Return {
    pub position        : Position,
    pub expr            : Expression,
}

impl_positioned!(Return);
impl_display!(Return, "return {}", expr);
impl_resolvable!(Return {
    expr: Item,
});


/// A break statement.
#[derive(Debug)]
pub struct Break {
    pub position: Position,
}

impl_positioned!(Break);
impl_resolvable!(always Break);
impl_display!(Break, "break");


/// A continue statement.
#[derive(Debug)]
pub struct Continue {
    pub position: Position,
}

impl_positioned!(Continue);
impl_resolvable!(always Continue);
impl_display!(Continue, "continue");


/// A deconstruction pattern.
#[derive(Debug)]
pub enum Pattern {
    SimpleVariant(Path),
}


/// A match block, e.g. `match e { Enum::Variant => { ... } }`.
#[derive(Debug)]
pub struct MatchBlock {
    pub position    : Position,
    pub expr        : Expression,
    pub branches    : Vec<(Pattern, Block)>,
    pub scope_id    : ScopeId,
}

impl_positioned!(MatchBlock);
impl_display!(MatchBlock, "match {} {{ ... }}", expr);
impl_resolvable!(MatchBlock {
    expr: Item,
    branches: ItemList1,
});

impl Typeable for MatchBlock {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        self.branches.first().unwrap().1.type_id(bindings)
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        self.branches.first_mut().unwrap().1.set_type_id(bindings, type_id)
    }
}

/// An if block, e.g. `if a { ... } else { ... }`.
#[derive(Debug)]
pub struct IfBlock {
    pub position    : Position,
    pub cond        : Expression,
    pub if_block    : Block,
    pub else_block  : Option<Block>,
    pub scope_id    : ScopeId,
}

impl_positioned!(IfBlock);
impl_display!(IfBlock, "if {} {{ ... }}", cond);
impl_resolvable!(IfBlock {
    cond: Item,
    if_block: Item,
    else_block: OptionalItem,
});

impl ControlFlow for IfBlock {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        if let cond_cf @ Some(_) = self.cond.identify_control_flow(scan_blocks) {
            // if-condition alters control flow
            cond_cf
        } else if let Some(else_block) = &self.else_block {
            // check whether both branches unconditionally alter the control flow in the same way.
            let if_cf = self.if_block.identify_control_flow(scan_blocks);
            if if_cf == else_block.identify_control_flow(scan_blocks) {
                if_cf
            } else {
                None
            }
        } else {
            // no else block so control flow could only ever be conditionally altered. (unless 'if true', but that should probably be optimized at a different stage)
            None
        }
    }
}

impl Typeable for IfBlock {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        self.if_block.result.as_ref().map_or(Some(TypeId::VOID), |e| e.type_id(bindings))
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        if let Some(result) = &mut self.if_block.result {
            result.set_type_id(bindings, type_id)
        } else {
            panic!("Cannot set return type of if statement (not an expression).")
        }
    }
}


/// A regular block.
#[derive(Debug)]
pub struct Block {
    pub position    : Position,
    pub statements  : Vec<Statement>,
    pub result      : Option<Expression>,
    pub scope_id    : ScopeId,
}

impl_positioned!(Block);
impl_display!(Block, "{{ ... }}");
impl_resolvable!(Block {
    statements: ItemList,
    result: OptionalItem,
});

impl Block {
    pub fn new(position: Position, scope_id: ScopeId, mut statements: Vec<Statement>, mut result: Option<Expression>) -> Self {
        // truncate dead code
        if let Some(control_flow_position) = statements.iter().position(|s| s.identify_control_flow(true).is_some()) {
            // TODO: implement warning support and attach a warning to the block ast node
            statements.truncate(control_flow_position + 1);
            result = None; // result would have followed the dead code and also be dead
        }
        if statements.last().map_or(false, |s| s.is_expression()) {
            result = statements.pop().unwrap().into_expression();
        }
        Block {
            position,
            statements,
            result,
            scope_id,
        }
    }
}

impl Typeable for Block {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        self.result.as_ref().map_or(Some(TypeId::VOID), |e| e.type_id(bindings))
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        if let Some(result) = &mut self.result {
            result.set_type_id(bindings, type_id)
        } else {
            panic!("Cannot to set return type of block statement (not an expression).")
        }
    }
}

impl ControlFlow for Block {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        // if dead code was already eliminated we know that any control flow change will happen in the result or last statement
        if let Some(result) = &self.result {
            if let Some(control_flow) = result.identify_control_flow(scan_blocks) {
                return Some(control_flow);
            }
        }
        if scan_blocks {
            self.statements.iter().find_map(|s| s.identify_control_flow(scan_blocks))
        } else {
            self.statements.last()?.identify_control_flow(scan_blocks)
        }
    }
}

/// An itsy expression.
pub enum Expression {
    Literal(Literal),
    Constant(Constant),
    Variable(Variable),
    Assignment(Box<Assignment>),
    BinaryOp(Box<BinaryOp>),
    UnaryOp(Box<UnaryOp>),
    Block(Box<Block>),
    IfBlock(Box<IfBlock>),
    MatchBlock(Box<MatchBlock>),
    Closure(Box<Closure>),
    AnonymousFunction(Box<Function>),
}

impl_resolvable!(enum Expression);
impl_as_getter!(Expression {
    pub as_literal: Literal -> &Literal,
    pub as_variable: Variable -> &Variable,
    pub as_constant: Constant -> &Constant,
    pub as_binary_op: BinaryOp -> &BinaryOp,
    pub as_binary_op_mut: BinaryOp -> mut BinaryOp,
});

impl Expression {
    // Creates a void expression used when 'nothing' is returned
    pub fn void(position: Position) -> Self {
        Expression::Literal(Literal {
            position,
            value       : LiteralValue::Void,
            type_name   : None,
            type_id     : Some(TypeId::VOID),
        })
    }
    pub fn is_zero_literal(self: &Self) -> bool {
        match self {
            Self::Literal(l) => match l.value {
                LiteralValue::Numeric(n) => match n {
                    Numeric::Float(f) if f == 0.0 => true,
                    Numeric::Signed(0) => true,
                    Numeric::Unsigned(0) => true,
                    _ => false,
                },
                LiteralValue::Bool(false) => true,
                _ => false,
            },
            _ => false,
        }
    }
}

impl Typeable for Expression {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        impl_matchall!(self, Expression, item, { item.type_id(bindings) })
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        impl_matchall!(self, Expression, item, { item.set_type_id(bindings, type_id) })
    }
}

impl ControlFlow for Expression {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        match self {
            Expression::Assignment(v)   => v.identify_control_flow(scan_blocks),
            Expression::BinaryOp(v)     => v.identify_control_flow(scan_blocks),
            Expression::UnaryOp(v)      => v.identify_control_flow(scan_blocks),
            Expression::Block(v)        => v.identify_control_flow(scan_blocks),
            Expression::IfBlock(v)      => v.identify_control_flow(scan_blocks),
            _                           => None,
        }
    }
}

impl Positioned for Expression {
    fn position(self: &Self) -> Position {
        impl_matchall!(self, Expression, item, { item.position() })
    }
}

impl Debug for Expression {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        impl_matchall!(self, Expression, item, { write!(f, "{:#?}", item) })
    }
}

impl Display for Expression {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        impl_matchall!(self, Expression, item, { write!(f, "{}", item) })
    }
}


/// A literal.
#[derive(Debug)]
pub struct Literal {
    pub position    : Position,
    pub value       : LiteralValue,
    pub type_name   : Option<TypeName>, // used in e.g. 1i8, 3.1415f32
    pub type_id     : Option<TypeId>,
}

impl_typeable!(Literal);
impl_positioned!(Literal);
impl_resolvable!(Literal {
    value: Item,
    type_name: OptionalItem,
    type_id: TypeId,
});

impl Display for Literal {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.value {
            LiteralValue::Void => write!(f, "void"),
            LiteralValue::Bool(v) => write!(f, "{:?}", v),
            LiteralValue::Numeric(v) => write!(f, "{}", v),
            LiteralValue::String(v) => write!(f, "{:?}", v),
            LiteralValue::Array(_) => write!(f, "[ ]"),
            LiteralValue::Struct(_) => write!(f, "struct {}", &self.type_name.as_ref().unwrap().path),
        }
    }
}

/// Value-storage for literals.
pub enum LiteralValue {
    Void,
    Bool(bool),
    Numeric(Numeric),
    String(String),
    Array(ArrayLiteral),
    Struct(StructLiteral),
}

impl LiteralValue {
    pub fn is_const(self: &Self) -> bool {
        match self {
            LiteralValue::Array(v) => v.elements.iter().all(|e| e.as_literal().map(|l| l.value.is_const()).unwrap_or(false)),
            LiteralValue::Struct(v) => v.fields.iter().all(|(_, e)| e.as_literal().map(|l| l.value.is_const()).unwrap_or(false)),
            _ => true,
        }
    }
    pub fn as_string(self: &Self) -> Option<&str> {
        match self {
            LiteralValue::String(v) => Some(v),
            _ => None,
        }
    }
    pub fn as_numeric(self: &Self) -> Option<Numeric> {
        match self {
            LiteralValue::Numeric(v) => Some(*v),
            _ => None,
        }
    }
    pub fn as_bool(self: &Self) -> Option<bool> {
        match self {
            LiteralValue::Bool(v) => Some(*v),
            _ => None,
        }
    }
    pub fn as_array(self: &Self) -> Option<&ArrayLiteral> {
        match self {
            LiteralValue::Array(v) => Some(v),
            _ => None,
        }
    }
    pub fn as_array_mut(self: &mut Self) -> Option<&mut ArrayLiteral> {
        match self {
            LiteralValue::Array(v) => Some(v),
            _ => None,
        }
    }
    pub fn as_struct_mut(self: &mut Self) -> Option<&mut StructLiteral> {
        match self {
            LiteralValue::Struct(v) => Some(v),
            _ => None,
        }
    }
}

impl Resolvable for LiteralValue {
    fn resolvables(self: &Self) -> Vec<Resolvables> {
        match self {
            Self::Array(array) => array.resolvables(),
            Self::Struct(struct_) => struct_.resolvables(),
            _ => vec![ Resolvables::Progress(Progress::new(1, 1)) ],
        }
    }
}

impl Display for LiteralValue {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LiteralValue::Void => write!(f, "void"),
            LiteralValue::Bool(v) => write!(f, "{:?}", v),
            LiteralValue::Numeric(v) => write!(f, "{:?}", v),
            LiteralValue::String(v) => write!(f, "\"{:?}\"", v),
            LiteralValue::Array(v) => write!(f, "{})", v),
            LiteralValue::Struct(v) => write!(f, "{:?}", v), // FIXME
        }
    }
}

impl Debug for LiteralValue {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LiteralValue::Void => write!(f, "void"),
            LiteralValue::Bool(v) => write!(f, "{:?}", v),
            LiteralValue::Numeric(v) => write!(f, "{:?}", v),
            LiteralValue::String(v) => write!(f, "String({:?})", v),
            LiteralValue::Array(v) => write!(f, "Array({:#?})", v),
            LiteralValue::Struct(v) => write!(f, "Struct({:#?})", v),
        }
    }
}

/// An inline array literal, e.g. `[ 2, 3, 5, 7 ]`.
#[derive(Debug)]
pub struct ArrayLiteral {
    pub elements: Vec<Expression>, // TODO: struct/array literals containing expressions should be expressions themselves instead of literals
}

impl_resolvable!(ArrayLiteral {
    elements: ItemList,
});

impl Display for ArrayLiteral {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "[ {} ]", self.elements.iter().map(|e| format!("{}", e)).collect::<Vec<String>>().join(", "))
    }
}


/// An inline struct literal, e.g. `MyStruct { a: 10, b: "Hello" }`.
#[derive(Debug)]
pub struct StructLiteral {
    pub fields: UnorderedMap<String, Expression>, // TODO: struct/array literals containing expressions should be expressions themselves instead of literals
}

impl_resolvable!(StructLiteral {
    fields: ItemMap,
});

impl Display for StructLiteral {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{{ {} }}", self.fields.iter().map(|(n, _)| format!("{}", n)).collect::<Vec<String>>().join(", "))
    }
}


/// A variable.
#[derive(Debug)]
pub struct Variable {
    pub position    : Position,
    pub ident       : Ident,
    pub binding_id  : BindingId,
}

impl_positioned!(Variable);
impl_display!(Variable, "{}", ident);
impl_resolvable!(Variable {
    binding_id: BindingId,
});

impl Typeable for Variable {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        bindings.binding_by_id(self.binding_id).type_id
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        bindings.binding_by_id_mut(self.binding_id).type_id = Some(type_id)
    }
}


/// A constant.
#[derive(Debug)]
pub struct Constant {
    pub position    : Position,
    pub path        : Path,
    pub constant_id : Option<ConstantId>,
}

impl_positioned!(Constant);
impl_display!(Constant, "{}", path);
impl_resolvable!(Constant {
    constant_id: ConstantId,
});

impl Typeable for Constant {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        match self.constant_id {
            Some(constant_id) => bindings.constant_by_id(constant_id).type_id,
            None => None,
        }
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        match self.constant_id {
            Some(constant_id) => bindings.constant_by_id_mut(constant_id).type_id = Some(type_id),
            None => { /* not resolved to constant yet */ },
        }
    }
}


/// A member identifier for a struct field.
#[derive(Debug)]
pub struct Member {
    pub position    : Position,
    pub ident       : Ident,
    pub type_id     : Option<TypeId>, // TODO this should be either type or constant id
    pub constant_id : Option<ConstantId>,
}

impl_typeable!(Member);
impl_positioned!(Member);
impl_display!(Member, "{}", ident);

impl Resolvable for Member {
    fn resolvables(self: &Self) -> Vec<Resolvables> {
        let mut result = Vec::new();
        if self.constant_id.is_some() {
            result.append(&mut impl_resolvable!(@append self.constant_id, ConstantId));
        } else {
            result.append(&mut impl_resolvable!(@append self.type_id, TypeId));
        }
        return result;
    }
}

/// Argument list of a function call.
#[derive(Debug)]
pub struct ArgumentList {
    pub position        : Position,
    pub args            : Vec<Expression>,
}

impl_positioned!(ArgumentList);
impl_resolvable!(ArgumentList {
    args: ItemList,
});

impl Display for ArgumentList {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.args.iter().map(|e| format!("{}", e)).collect::<Vec<String>>().join(", "))
    }
}

impl ControlFlow for ArgumentList {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        self.args.iter().find_map(|s| s.identify_control_flow(scan_blocks)) // FIXME what if return after break block argument?
    }
}


/// A variable assignment within an expression, e.g. `x = 10`.
#[derive(Debug)]
pub struct Assignment {
    pub position: Position,
    pub op      : BinaryOperator,
    pub left    : Expression,
    pub right   : Expression,
    pub type_id : Option<TypeId>,
}

impl_typeable!(Assignment);
impl_positioned!(Assignment);
impl_display!(Assignment, "{} {} {}", left, op, right);
impl_resolvable!(Assignment {
    left: Item,
    right: Item,
    type_id: TypeId,
});

impl ControlFlow for Assignment {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        // We priorize left over right control flow as that is the order of evaluation for assignments.
        self.left.identify_control_flow(scan_blocks).or(self.right.identify_control_flow(scan_blocks))
    }
}


/// An explicit `as` type-cast.
#[derive(Debug)]
pub struct Cast {
    pub position    : Position,
    pub expr        : Expression,
    pub ty          : TypeName,
    pub type_id     : Option<TypeId>,
}

impl_typeable!(Cast);
impl_positioned!(Cast);
impl_display!(Cast, "{} as {}", expr, ty);
impl_resolvable!(Cast {
    expr: Item,
    ty: Item,
    type_id: TypeId,
});

impl ControlFlow for Cast {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        self.expr.identify_control_flow(scan_blocks)
    }
}

/// An operand for a binary operation.
#[derive(Debug)]
pub enum BinaryOperand {
    Expression(Expression),
    ArgumentList(ArgumentList),
    Member(Member),
    TypeName(TypeName),
}

impl_resolvable!(enum BinaryOperand);

impl_as_getter!(BinaryOperand {
    pub as_expression: Expression -> &Expression,
    pub as_expression_mut: Expression -> mut Expression,
    pub is_expression: Expression ? bool,
    pub as_argument_list: ArgumentList -> &ArgumentList,
    pub as_argument_list_mut: ArgumentList -> mut ArgumentList,
    pub as_member: Member -> &Member,
    pub as_member_mut: Member -> mut Member,
    pub as_type_name: TypeName -> &TypeName,
    pub as_type_name_mut: TypeName -> mut TypeName,
});

impl Typeable for BinaryOperand {
    fn type_id(self: &Self, bindings: &impl MetaContainer) -> Option<TypeId> {
        match self {
            Self::Expression(v) => v.type_id(bindings),
            Self::ArgumentList(_) => panic!("ArgumentList is not typeable."),
            Self::Member(v) => v.type_id(bindings),
            Self::TypeName(v) => v.type_id(bindings),
        }
    }
    fn set_type_id(self: &mut Self, bindings: &mut impl MetaContainer, type_id: TypeId) {
        match self {
            Self::Expression(v) => v.set_type_id(bindings, type_id),
            Self::ArgumentList(_) => panic!("ArgumentList is not typeable."),
            Self::Member(v) => v.set_type_id(bindings, type_id),
            Self::TypeName(v) => v.set_type_id(bindings, type_id),
        }
    }
}

impl Display for BinaryOperand {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Expression(v) => write!(f, "{v}"),
            Self::ArgumentList(v) => write!(f, "{v}"),
            Self::Member(v) => write!(f, "{v}"),
            Self::TypeName(v) => write!(f, "{v}"),
        }
    }
}

impl ControlFlow for BinaryOperand {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        match self {
            Self::Expression(v) => v.identify_control_flow(scan_blocks),
            Self::ArgumentList(v) => v.identify_control_flow(scan_blocks),
            _ => None,
        }
    }
}


/// A binary operation within an expression.
#[derive(Debug)]
pub struct BinaryOp {
    pub position    : Position,
    pub op          : BinaryOperator,
    pub left        : BinaryOperand,
    pub right       : BinaryOperand,
    pub type_id     : Option<TypeId>,
}

impl_typeable!(BinaryOp);
impl_positioned!(BinaryOp);
impl_display!(BinaryOp, "{}{}{}", left, op, right);
impl_resolvable!(BinaryOp {
    left: Item,
    right: Item,
    type_id: TypeId,
});

impl ControlFlow for BinaryOp {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        // We priorize left over right control flow as that is the order of evaluation for binary operations.
        self.left.identify_control_flow(scan_blocks).or(self.right.identify_control_flow(scan_blocks))
    }
}

/// A unary operation within an expression.
#[derive(Debug)]
pub struct UnaryOp {
    pub position    : Position,
    pub op          : UnaryOperator,
    pub expr        : Expression,
    pub type_id     : Option<TypeId>,
}

impl_typeable!(UnaryOp);
impl_positioned!(UnaryOp);
impl_resolvable!(UnaryOp {
    expr: Item,
    type_id: TypeId,
});

impl Display for UnaryOp {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}{}", self.op, self.expr)
    }
}

impl ControlFlow for UnaryOp {
    fn identify_control_flow(self: &Self, scan_blocks: bool) -> Option<ControlFlowType> {
        self.expr.identify_control_flow(scan_blocks)
    }
}


/// A unary operator used in unary expressions.
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum UnaryOperator {
    // boolean
    Not,
    // positive/negavtive
    Plus,
    Minus,
}

impl UnaryOperator {
    pub fn prefix_from_string(op: &str) -> Self {
        match op {
            "!" => UnaryOperator::Not,
            _ => panic!("Parser yielded invalid prefix operator \"{}\".", op),
        }
    }
    pub fn suffix_from_string(op: &str) -> Self {
        match op {
            _ => panic!("Parser yielded invalid prefix operator \"{}\".", op),
        }
    }
}

impl Display for UnaryOperator {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", match self {
            UnaryOperator::Not => "!",
            UnaryOperator::Plus => "+",
            UnaryOperator::Minus => "-",
        })
    }
}


/// A binary operator used in binary expressions.
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum BinaryOperator {
    // arithmetic
    Add, Sub, Mul, Div, Rem,
    // assigments
    Assign, AddAssign, SubAssign, MulAssign, DivAssign, RemAssign,
    // comparison
    Less, Greater, LessOrEq, GreaterOrEq, Equal, NotEqual,
    // boolean
    And, Or,
    // iterator
    Range, RangeInclusive,
    // data offsets
    Index, IndexWrite, Access, AccessWrite,
    // misc
    Call, Cast,
}

impl BinaryOperator {
    pub fn from_string(op: &str) -> Self {
        match op {

            "=" => BinaryOperator::Assign,
            "+" => BinaryOperator::Add,
            "-" => BinaryOperator::Sub,
            "*" => BinaryOperator::Mul,
            "/" => BinaryOperator::Div,
            "%" => BinaryOperator::Rem,

            "&&" => BinaryOperator::And,
            "||" => BinaryOperator::Or,

            "<" => BinaryOperator::Less,
            ">" => BinaryOperator::Greater,
            "<=" => BinaryOperator::LessOrEq,
            ">=" => BinaryOperator::GreaterOrEq,
            "==" => BinaryOperator::Equal,
            "!=" => BinaryOperator::NotEqual,

            "+=" => BinaryOperator::AddAssign,
            "-=" => BinaryOperator::SubAssign,
            "*=" => BinaryOperator::MulAssign,
            "/=" => BinaryOperator::DivAssign,
            "%=" => BinaryOperator::RemAssign,

            ".." => BinaryOperator::Range,
            "..=" => BinaryOperator::RangeInclusive,
            "." => BinaryOperator::Access,

            _ => panic!("Parser yielded invalid binary operator \"{}\".", op),
        }
    }
    pub fn is_simple(self: &Self) -> bool {
        use BinaryOperator as BO;
        match self {
            BO::Add | BO::Sub | BO::Mul | BO::Div | BO::Rem => true,
            BO::Less | BO::Greater | BO::LessOrEq | BO::GreaterOrEq | BO::Equal | BO::NotEqual => true,
            _ => false,
        }
    }
    pub fn is_shortcircuit(self: &Self) -> bool {
        use BinaryOperator as BO;
        match self {
            BO::And | BO::Or => true,
            _ => false,
        }
    }
    pub fn is_offset(self: &Self) -> bool {
        use BinaryOperator as BO;
        match self {
            BO::Index | BO::IndexWrite | BO::Access | BO::AccessWrite => true,
            _ => false,
        }
    }
    pub fn is_compound(self: &Self) -> bool {
        use BinaryOperator as BO;
        match self {
            BO::AddAssign | BO::SubAssign | BO::MulAssign | BO::DivAssign | BO::RemAssign => true,
            _ => false,
        }
    }
}

impl Display for BinaryOperator {
    fn fmt(self: &Self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", match self {
            BinaryOperator::Assign          => " = ",
            BinaryOperator::Add             => " + ",
            BinaryOperator::Sub             => " - ",
            BinaryOperator::Mul             => " * ",
            BinaryOperator::Div             => " / ",
            BinaryOperator::Rem             => " % ",

            BinaryOperator::And             => " && ",
            BinaryOperator::Or              => " || ",

            BinaryOperator::Less            => " < ",
            BinaryOperator::Greater         => " > ",
            BinaryOperator::LessOrEq        => " <= ",
            BinaryOperator::GreaterOrEq     => " >= ",
            BinaryOperator::Equal           => " == ",
            BinaryOperator::NotEqual        => " != ",

            BinaryOperator::AddAssign       => " += ",
            BinaryOperator::SubAssign       => " -= ",
            BinaryOperator::MulAssign       => " *= ",
            BinaryOperator::DivAssign       => " /= ",
            BinaryOperator::RemAssign       => " %= ",

            BinaryOperator::Range           => "..",
            BinaryOperator::RangeInclusive  => "..=",
            BinaryOperator::Access          => ".",
            BinaryOperator::AccessWrite     => ".",
            BinaryOperator::Index           => "[] ",
            BinaryOperator::IndexWrite      => "[] ",

            BinaryOperator::Call            => "(", // FIXME: add closing somewhere?
            BinaryOperator::Cast            => " as ",
        })
    }
}
