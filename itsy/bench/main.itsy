/*
 * Basic ballpark benchmarking. TODO: super clunky due to lack of closures and hashmaps.
 */

struct Test {
    name: String,
    itsy_time: f64,
    rust_time: f64,
}

struct ConstructTestInner {
    c: i32,
    d: u64,
}

struct ConstructTest {
    a: ConstructTestInner,
    b: [ u64 ],
}

fn bench_mandelbrot(results: [ Test ]) {

    start_time();
    let rust_result = rust_mandelbrot(800, 600);
    let rust_time = stop_time();

    start_time();
    let itsy_result = itsy_mandelbrot(800, 600);
    let itsy_time = stop_time();

    if itsy_result != rust_result {
        print("ERROR: {itsy_result} != {rust_result}");
    }

    results.push(Test { name: "mandelbrot", rust_time: rust_time, itsy_time: itsy_time });
}

fn bench_fib_r(results: [ Test ]) {

    start_time();
    let rust_result = rust_fib_r(32);
    let rust_time = stop_time();

    start_time();
    let itsy_result = itsy_fib_r(32);
    let itsy_time = stop_time();

    if itsy_result != rust_result {
        print("ERROR: {itsy_result} != {rust_result}");
    }

    results.push(Test { name: "fib_r", rust_time: rust_time, itsy_time: itsy_time });
}

fn bench_stringcat(results: [ Test ]) {

    start_time();
    let rust_result = rust_stringcat(5000);
    let rust_time = stop_time();

    start_time();
    let itsy_result = itsy_stringcat(5000);
    let itsy_time = stop_time();

    if itsy_result != rust_result {
        print("ERROR: {itsy_result} != {rust_result}");
    }

    results.push(Test { name: "stringcat", rust_time: rust_time, itsy_time: itsy_time });
}

fn bench_upload_struct(results: [ Test ]) {

    start_time();

    for i in 0..1000000 {
        // partially dynamic contents -> upload opcode
        let item = ConstructTest { a: ConstructTestInner { c: 14, d: i }, b: [ 1, 2, i, 8, 131231 ] };
    }

    let itsy_time = stop_time();

    results.push(Test { name: "upload_struct", rust_time: 0.0, itsy_time: itsy_time });
}

fn bench_upload_array(results: [ Test ]) {

    start_time();

    for i in 0..1000000 {
        // static contents -> construct opcode
        let item = [
            [ 1u64, i, 3, 4 ],
            [ 5, i, 7, 8, 9 ],
            [ i, 11, 12 ],
            [ 13, 14, i, 16, 17, 18 ],
            [ 19, i ],
        ];
    }

    let itsy_time = stop_time();

    results.push(Test { name: "upload_array", rust_time: 0.0, itsy_time: itsy_time });
}

fn bench_construct_struct(results: [ Test ]) {

    start_time();

    for i in 0..1000000 {
        // static contents -> construct opcode
        let item = ConstructTest { a: ConstructTestInner { c: 14, d: 894839483 }, b: [ 1, 2, 4, 8, 131231 ] };
    }

    let itsy_time = stop_time();

    results.push(Test { name: "construct_struct", rust_time: 0.0, itsy_time: itsy_time });
}

fn bench_construct_array(results: [ Test ]) {

    start_time();

    for i in 0..1000000 {
        // static contents -> construct opcode
        let item = [
            [ 1u64, 2, 3, 4 ],
            [ 5, 6, 7, 8, 9 ],
            [ 10, 11, 12 ],
            [ 13, 14, 15, 16, 17, 18 ],
            [ 19, 20 ],
        ];
    }

    let itsy_time = stop_time();

    results.push(Test { name: "construct_array", rust_time: 0.0, itsy_time: itsy_time });
}

fn bench_string_return(results: [ Test ]) {

    start_time();

    let result: [ String ] = [ ];

    for i in 0..1500 {
        let item = "Hello".repeat(50000);
        result.push(item);
    }

    let itsy_time = stop_time();

    results.push(Test { name: "string_return", rust_time: 0.0, itsy_time: itsy_time });
}

fn bench_heap_reuse(results: [ Test ]) {

    start_time();

    for i in 0..9000 {
        let item = "Hello".repeat(50000);
    }

    let itsy_time = stop_time();

    results.push(Test { name: "heap_reuse", rust_time: 0.0, itsy_time: itsy_time });
}

fn print_results(passes: [ [ Test ] ]) {

    for t in 0..passes[0].len() {

        let itsy_avg = 0.0;
        let rust_avg = 0.0;
        println(passes[0][t].name);

        for source in [ "itsy", "rust" ] {

            let min = 0.0;
            let max = 0.0;
            let sum = 0.0;

            for p in 0..passes.len() {
                let time = if source == "itsy" { passes[p][t].itsy_time } else { passes[p][t].rust_time };
                sum += time;
                if (min == 0.0 || min > time) {
                    min = time;
                }
                if (max < time) {
                    max = time;
                }
            }

            let avg = sum / passes.len() as f64;

            if source == "itsy" {
                itsy_avg = avg
            } else {
                rust_avg = avg
            }

            if sum > 0.0 {
                println("  {source} avg: {avg.fmt(4)} min: {min.fmt(4)} max: {max.fmt(4)} var: {((max-min)/min*100.0).fmt(3)}%");
            }
        }

        if rust_avg > 0.0 {
            println("  factor {(itsy_avg / rust_avg).fmt(2)}x");
        }
    }
}

fn main() {

    let num_passes = 5;
    let passes: [ [ Test ] ] = [ ];
    println("Ballpark Bench™ - Measuring in approximate baseball fields");
    print("running {num_passes} passes, pass ");

    for pass in 0..num_passes {
        print((pass + 1) as String + "...");
        let pass_results: [ Test ] = [ ];
        bench_mandelbrot(pass_results); // todo: need closures here
        heap_purge();
        bench_fib_r(pass_results);
        heap_purge();
        bench_stringcat(pass_results);
        heap_purge();
        bench_construct_struct(pass_results);
        heap_purge();
        bench_upload_struct(pass_results);
        heap_purge();
        bench_construct_array(pass_results);
        heap_purge();
        bench_upload_array(pass_results);
        heap_purge();
        bench_string_return(pass_results);
        heap_purge();
        bench_heap_reuse(pass_results);
        heap_purge();
        passes.push(pass_results);
    }

    println("");
    print_results(passes);
}

fn itsy_fib_r(n: i32) -> i32 {
    if n < 2 {
        n
    } else {
        itsy_fib_r(n - 1) + itsy_fib_r(n - 2)
    }
}

fn itsy_mandelbrot(columns: u32, rows: u32) -> String {

    let chars = [ ".", ",", "`", "´", "'", "~", "^", "°", "$", ";", "=", "o", "O", "%", "&", ":" ];
    let result = "";
    let max_x = columns as f32;
    let max_y = rows as f32;
    let y = -1.4f32;

    for _ in 0..rows {
        let x = -2.0f32;
        let line = "";
        for _ in 0..columns {
            let r = 0f32;
            let i = 0f32;
            let n = 0;
            while n < 16 && r * r + i * i <= 4.0 {
                r = r * r - i * i + x;
                i = 2.0 * r * i + y;
                n += 1;
            }
            line += chars[n-1];
            x += 3.6 / max_x;
        }
        result += line + "\n";
        y += 2.81 / max_y;
    }

    result
}

fn itsy_stringcat(n: i32) -> String {
    let s = n as String;
    if n > 0 {
        s += itsy_stringcat(n - 1);
    }
    s
}
