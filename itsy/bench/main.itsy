/*
 * Basic ballpark benchmarking. Not to be taken too seriously.
 */
use BenchAPI::{print, println, start_time, stop_time, heap_purge, rust_mandelbrot, rust_fib_r, rust_stringcat};

struct CompareBench {
    name: String,
    itsy: fn() -> String,
    rust: fn() -> String,
}

struct SingleBench {
    name: String,
    itsy: fn(),
}

struct Result {
    name: String,
    itsy_time: f64,
    rust_time: f64,
}

fn print_results(results: [ [ Result ] ]) {

    for t in 0..results[0].len() {

        let itsy_avg = 0.0;
        let rust_avg = 0.0;
        println(results[0][t].name);

        for source in [ "itsy", "rust" ] {

            let min = 0.0;
            let max = 0.0;
            let sum = 0.0;

            for p in 0..results.len() {
                let time = if source == "itsy" { results[p][t].itsy_time } else { results[p][t].rust_time };
                sum += time;
                if (min == 0.0 || min > time) {
                    min = time;
                }
                if (max < time) {
                    max = time;
                }
            }

            let avg = sum / results.len() as f64;

            if source == "itsy" {
                itsy_avg = avg
            } else {
                rust_avg = avg
            }

            if sum > 0.0 {
                println("  {source} avg: {avg.fmt(4)} min: {min.fmt(4)} max: {max.fmt(4)} var: {((max-min)/min*100.0).fmt(3)}%");
            }
        }

        if rust_avg > 0.0 {
            println("  factor {(itsy_avg / rust_avg).fmt(2)}x");
        }
    }
}

fn bench_single(name: String, itsy: fn(), results: [ Result ]) {
    start_time();
    itsy();
    results.push(Result { name: name, rust_time: 0.0, itsy_time: stop_time() });
}

fn bench_compare(name: String, itsy: fn() -> String, rust: fn() -> String, results: [ Result ]) {
    start_time();
    let rust_result = rust();
    let rust_time = stop_time();
    start_time();
    let itsy_result = itsy();
    let itsy_time = stop_time();
    if itsy_result != rust_result {
        print("ERROR: {itsy_result} != {rust_result}");
    }
    results.push(Result { name: name, rust_time: rust_time, itsy_time: itsy_time });
}

fn main() {
    let compares = [
        CompareBench { name: "mandelbrot", itsy: fn() -> String { itsy_mandelbrot(800, 600) }, rust: fn() -> String { rust_mandelbrot(800, 600) } },
        CompareBench { name: "fib_r", itsy: fn() -> String { itsy_fib_r(32) as String }, rust: fn() -> String { rust_fib_r(32) as String } },
        CompareBench { name: "stringcat", itsy: fn() -> String { itsy_stringcat(5000) }, rust: fn() -> String { rust_stringcat(5000) } },
    ];
    let singles = [
        SingleBench { name: "upload_struct", itsy: itsy_upload_struct },
        SingleBench { name: "upload_array", itsy: itsy_upload_array },
        SingleBench { name: "string_return", itsy: itsy_string_return },
        SingleBench { name: "heap_reuse", itsy: itsy_heap_reuse },
    ];
    let num_passes = 5;
    let results: [ [ Result ] ] = [ ];

    println("Ballpark Bench™ - Measuring in approximate baseball fields");
    print("running {num_passes} passes, pass ");

    for pass in 0..num_passes {
        print("{pass+1}...");
        let pass_results: [ Result ] = [ ];
        for compare in compares {
            bench_compare(compare.name, compare.itsy, compare.rust, pass_results);
            heap_purge();
        }
        for single in singles {
            bench_single(single.name, single.itsy, pass_results);
            heap_purge();
        }
        results.push(pass_results);
    }

    println("");
    print_results(results);
}

struct ConstructTestInner {
    c: i32,
    d: u64,
    e: f32,
    f: i8,
}

struct ConstructTest {
    a: ConstructTestInner,
    b: u8,
    c: i64,
    d: f32,
    e: [ u64 ],
}

fn itsy_fib_r(n: i32) -> i32 {
    if n < 2 {
        n
    } else {
        itsy_fib_r(n - 1) + itsy_fib_r(n - 2)
    }
}

fn itsy_mandelbrot(columns: u32, rows: u32) -> String {

    let chars = [ ".", ",", "`", "´", "'", "~", "^", "°", "$", ";", "=", "o", "O", "%", "&", ":" ];
    let result = "";
    let max_x = columns as f32;
    let max_y = rows as f32;
    let y = -1.4f32;

    for _ in 0..rows {
        let x = -2.0f32;
        let line = "";
        for _ in 0..columns {
            let r = 0f32;
            let i = 0f32;
            let n = 0;
            while n < 16 && r * r + i * i <= 4.0 {
                r = r * r - i * i + x;
                i = 2.0 * r * i + y;
                n += 1;
            }
            line += chars[n-1];
            x += 3.6 / max_x;
        }
        result += line + "\n";
        y += 2.81 / max_y;
    }

    result
}

fn itsy_stringcat(n: i32) -> String {
    let s = n as String;
    if n > 0 {
        s += itsy_stringcat(n - 1);
    }
    s
}

fn itsy_upload_struct() {
    for i in 0..1000000 {
        // partially dynamic contents -> upload opcode
        let item = ConstructTest { a: ConstructTestInner { c: 14, d: i, e: 3.14, f: -21 }, b: 17, c: i as i64, d: 1.7, e: [ 1, 2, i, 8, 131231 ] };
    }
}

fn itsy_upload_array() {
    for i in 0..1000000 {
        // static contents -> construct opcode
        let item = [
            [ 1u64, i, 3, 4 ],
            [ 5, i, 7, 8, 9 ],
            [ i, 11, 12 ],
            [ 13, 14, i, 16, 17, 18 ],
            [ 19, i ],
        ];
    }
}

fn itsy_string_return() {
    let result: [ String ] = [ ];
    for i in 0..1500 {
        let item = "Hello".repeat(50000);
        result.push(item);
    }
}

fn itsy_heap_reuse() {
    for i in 0..9000 {
        let item = "Hello".repeat(50000);
    }
}
