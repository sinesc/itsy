struct StructA {
    a: u8,
}

struct StructB {
    b: u64,
}

pub trait TestTrait {
    fn required(self: Self, value: u8) -> u8;
    fn provided(self: Self, value: u8) -> u8 {
        prints("TestTrait::provided");
        //self.required() // TODO: requires dynamic constructor resolution (for refcounting)
        value
    }
}

impl TestTrait for StructA {
    fn required(self: Self, value: u8) -> u8 {
        prints("StructA::required");
        self.a + value
    }
}

impl TestTrait for StructB {
    fn required(self: Self, value: u8) -> u8 {
        prints("StructB::required");
        self.b as u8
    }
}

fn doStuff(stuff: TestTrait) {
    printu8(stuff.provided(3));
    printu8(stuff.required(9));
}

fn main() {
    let a = StructA { a: 10 };
    let b = StructB { b: 9876543210 };
    doStuff(a);
    doStuff(b);
    printu8(a.provided(7));
    printu8(a.required(3));
}
